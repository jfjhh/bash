#!/bin/bash
#
# A countdown timer.

# Trap the exit to clean the screen a bit
function quit
{
	if [ "$SCREEN" != "$TTY" ] && !$IMMEDIATE; then
		eval "`resize -s $OLD_LINES $OLD_COLUMNS`"
	fi
	tput rmcup
	tput cnorm
	tput sgr0
	[ -z "$1" ] && exit 0 || exit $1
}
trap quit SIGINT SIGTERM

# Print long usage and exit.
function long_usage
{
	cat "$HOME/bin/countdown-help.txt" | less
	quit
}

# Print long usage and exit.
function usage
{
	if [ -n "$1" ]; then
		echo "Error: $1" 1>&2
	fi

	cat <<-EOF 1>&2
	Usage: countdown {-h, -H} {-i} [{-o, -t} time] {-n name}
	Use -H for long help.
	EOF

	quit 1
}

# Visual alert.
function play_sound
{
	if [ $IN_XFCE ]; then
		notify-send -u low "$MESSAGE"
	fi

	tput cuf $DEFAULT_OFFSET
	echo -n $DEFAULT_MESSAGE
	tput cr
	aplay $SOUND &> /dev/null &
}

# Add to a time and possibly 'wrap over' to past midnight or noon.
# Always to be called with 3 arguments: The (clock) time and the (offset)
# time to add to it, as well as a place (h, m, s), to specify hours,
# minutes, or seconds.
function add_times
{
	CLOCK=$1
	shift
	OFFSET=$1
	shift
	PLACE=$1

	PLACE_MAX=0

	if [ "$PLACE" == "h" ]; then
		PLACE_MAX=24
	elif [ "$PLACE" == "m" -o "$PLACE" == "s" ]; then
		PLACE_MAX=60
	else
		echo "Bad option to add_times" 1>&2
		quit 2
	fi

	let NEW_CLOCK=$CLOCK+$OFFSET
	[ $NEW_CLOCK -ge $PLACE_MAX ] && let NEW_CLOCK-=$PLACE_MAX
	echo -n $NEW_CLOCK
}

# Launch messages.
function print_info
{
	FIN_HOURS=`add_times $HOURS $DEST_HOURS "h"`
	FIN_MINUTES=`add_times $MINUTES $DEST_MINUTES "m"`
	FIN_SECONDS=`add_times $SECONDS $DEST_SECONDS "s"`

	[ $FIN_SECONDS -lt $DEST_SECONDS ] && let FIN_MINUTES++
	[ $FIN_MINUTES -lt $DEST_MINUTES ] && let FIN_HOURS++

	tput cud1
	tput cuf $HEAD_OFFSET
	printf "Running countdown: Started at: %02d:%02d:%02d.\n" \
		$HOURS $MINUTES $SECONDS
	tput cuf $HEAD_OFFSET
	printf "Total time: %02d:%02d:%02d, Ends at: %02d:%02d:%02d.\n" \
		$DEST_HOURS $DEST_MINUTES $DEST_SECONDS \
		$FIN_HOURS $FIN_MINUTES $FIN_SECONDS
	echo

	tput dim
	tput cuf1; echo "$SPACER_STR"
	tput cuf1; echo -n "|"; tput cuf $[$SPACER_LENGTH-2]; echo "|"
	tput cuf1; echo -n "|"; tput cuf $[$SPACER_LENGTH-2]; echo "|"
	tput cuf1; echo -n "|"; tput cuf $[$SPACER_LENGTH-2]; echo "|"
	tput cuf1; echo "$SPACER_END_STR"
	tput sgr0

	tput cuu 3
}

# Verifies if a time is in the future or not.
function verify_time
{
	# The times as one big number.
	TMP="`echo -n \"$HOURS$MINUTES$SECONDS\" | \
		sed 's/^0\+//g'`"
	[ -z "$TMP" ] && TOTAL="0" || TOTAL="$TMP"

	TMP="`echo \"$DEST_HOURS$DEST_MINUTES$DEST_SECONDS\" | \
		sed 's/^0\+//g'`"
	[ -z "$TMP" ] && DEST_TOTAL="0" || DEST_TOTAL="$TMP"

	let DIFFERENCE=$DEST_TOTAL-$TOTAL

	TIME_OK=false

	if [ "$MODE" == "-c" ]; then
		# Countdown mode: Goes to -1 to display all zeros at the end.
		[ "$DEST_TOTAL" -gt 0 ] && TIME_OK=true || TIME_OK=false
	elif [ "$MODE" == "-o" ]; then
		# Offset mode.
		[ "$DEST_TOTAL" -gt 0 ] && TIME_OK=true || TIME_OK=false
	elif [ "$MODE" == "-t" ]; then
		# (Absolute) Time mode.
		[ "$DIFFERENCE" -gt 0 ] && TIME_OK=true || TIME_OK=false
	else
		TIME_OK=false
	fi

}

# Counts down a second.
function step_down
{
	if [ $DEST_MINUTES -eq 0 ]; then
		if [ $DEST_HOURS -ne 0 -a $DEST_SECONDS -le 0 ]; then
			let DEST_HOURS-=1
			let DEST_MINUTES=59
			let DEST_SECONDS=60
			# elif [ $DEST_HOURS -ne 0 -a $DEST_SECONDS -eq 0 ]; then
			# 	let DEST_MINUTES=59
		fi
	fi

	if [ $DEST_SECONDS -le 0 ]; then
		[ $DEST_MINUTES -ne 0 ] && let DEST_SECONDS=59
		[ $DEST_MINUTES -ne 0 ] && let DEST_MINUTES-=1
	else
		let DEST_SECONDS-=1
	fi
}

# Prints and changes the timer status.
function manage_time
{
	printf "%02dh:%02dm:%02ds" \
		$DEST_HOURS $DEST_MINUTES $DEST_SECONDS
	tput cub $TIMER_LENGTH

	verify_time
	step_down
	#
	# This constant is derived from extensive testing with a sleep time of 1
	# second, and accounts for the lag of running all these commands between
	# each second. By having a shorter sleep time, the execution of 1
	# second's worth of steps actually takes 1 second, instead of the
	# experimental result: 1 and 0.00591697929... seconds.
	#
	# Times are now roughly estimated to be accurate to the half second.
	#
	# sleep 1
	#
	sleep 0.994083
}

# Prints cool binary background
function bin_bg
{
	tput cup 0 0
	tput setaf 233
	COUNT=0
	MAX_COUNT=$(( (`tput lines`*`tput cols`)-1 ))
	while [ $COUNT -le $MAX_COUNT ]; do
		echo -n $[$RANDOM%2]
		let COUNT++
	done
	tput cup 0 0
	tput sgr0
}

[ $# -lt 1 ] && usage "Not enough arguments."

# Figure out if this is in xfce (my desktop).
IN_XFCE=false
[ -n `which xfce` ] && [ -n "$DISPLAY" ] && IN_XFCE=true

# Parse args from command line.
MODE=""
ARGTIME=""
NAME=""
IMMEDIATE=false
while getopts ":o:t:n:hHi" OPT; do
	case $OPT in
		o) MODE="-o"
			ARGTIME="$OPTARG"
			;;
		t)
			MODE="-t"
			ARGTIME="$OPTARG"
			;;
		n)
			NAME="$OPTARG"
			;;
		h)
			usage
			;;
		H)
			long_usage
			;;
		i)
			IMMEDIATE=true
			;;
		\?)
			usage "Invalid option: -$OPTARG."
			;;
		:)
			usage "-$OPTARG needs an argument."
			;;
	esac
done

# Check the specified time for validity.
ARGTIME_IS_VALID=false

if echo -n $ARGTIME | grep -q '^[0-9]\{2\}[\: ][0-9]\{2\}[\: ][0-9]\{2\}$'; then
	HOUR_MAX=0
	MIN_SEC_MAX=59
	if [ "$MODE" == "-o" ]; then
		HOUR_MAX=99
	elif [ "$MODE" == "-t" ]; then
		HOUR_MAX=23
	fi

	# Parse ARGTIME into variables.
	DEST_HOURS="`echo -n $ARGTIME | \
		sed -e 's/\(^[0-9]\{2\}\).*/\1/' -e 's/^0//'`"
	DEST_MINUTES="`echo -n $ARGTIME | \
		sed -e 's/.*[\: ]\([0-9]\{2\}\)[\: ].*/\1/' -e 's/^0//'`"
	DEST_SECONDS="`echo -n $ARGTIME | \
		sed -e 's/.*\([0-9]\{2\}$\)/\1/' -e 's/^0//'`"

	[ $DEST_HOURS -le $HOUR_MAX -a $DEST_MINUTES -le $MIN_SEC_MAX -a \
		$DEST_SECONDS -le $MIN_SEC_MAX ] && ARGTIME_IS_VALID=true
fi

if ! $ARGTIME_IS_VALID; then
	usage "The time string '$ARGTIME' is invalid."
fi

# Get the current time and strip leading zeros.
HOURS="`date +'%H' | sed 's/^0//'`"
MINUTES="`date +'%M' | sed 's/^0//'`"
SECONDS="`date +'%S' | sed 's/^0//'`"

# Set variables for the title of the timer to be printed in the terminal.
[ -z "$NAME" -o ${#NAME} -lt 5 ] && TITLE=" Timer " || TITLE=" $NAME "
let TITLE_LEN=${#TITLE}+2

let TITLE_PLUS=$TITLE_LEN+5
WORK_COLS=$(( 42+(42/(4-2)) )) # Why not include 42, 3 times? *Magic* number.
[ $WORK_COLS -gt $TITLE_PLUS ] && SPACER_NUM=$WORK_COLS || \
	SPACER_NUM=$TITLE_PLUS
let SPACER_NUM_OFFSET=$SPACER_NUM-1
SPACER_CHAR='='

let SPACER_NUM_HALF=$(( ($SPACER_NUM-$TITLE_LEN)/2 ))
let FIRST_NUM_SPACERS=$(( $SPACER_NUM_HALF+($SPACER_NUM_HALF%2) ))
let END_NUM_SPACERS=$(( $SPACER_NUM_HALF+($SPACER_NUM_HALF%2) ))

FIRST_SPACERS="+`for i in \`seq 1 $FIRST_NUM_SPACERS\`; do printf \"$SPACER_CHAR\"; done`"
END_SPACERS="`for i in \`seq 1 $END_NUM_SPACERS\`; do printf \"$SPACER_CHAR\"; done`+"

TIMER_FORMAT="00h:00m:00s"
TIMER_LENGTH=${#TIMER_FORMAT}
TIMER_OFFSET=$(( ($SPACER_NUM-$TIMER_LENGTH)/2 ))

SPACER_STR="$FIRST_SPACERS$TITLE$END_SPACERS"
SPACER_END_STR="`echo $SPACER_STR | sed 's/[^+]/'$SPACER_CHAR'/g'`"
SPACER_LENGTH=${#SPACER_STR}

# 40 is the length of the header lines.
HEAD_OFFSET=$(( (($SPACER_NUM-40)/2)+($SPACER_NUM%2) ))

# The sound for the notification.
SOUND="$HOME/button-09.wav"

# Message strings
DEFAULT_MESSAGE="The countdown timer has finished."
DEFAULT_OFFSET=$(( ($SPACER_NUM-${#DEFAULT_MESSAGE})/2 ))
[ -z "$NAME" ] && MESSAGE="$DEFAULT_MESSAGE" \
	|| MESSAGE="The countdown timer '$NAME' has finished."

# The colors for tput.
COLOR_MIN=17
COLOR_MAX=231
COLOR=$COLOR_MIN

# Possibly resize the terminal
SCREEN="`screen -list | grep -o 'pts-[0-9]\+'`"
TTY="`tty | sed 's/\/dev\///g'`"
# [ $SPACER_NUM -gt $SPACER_LENGTH ] && WIDTH=$SPACER_NUM || WIDTH=$SPACER_LENGTH
WIDTH=$SPACER_LENGTH
if [ "$SCREEN" != "$TTY" ] && !$IMMEDIATE; then
	OLD_LINES="$LINES"
	OLD_COLUMNS="$COLUMNS"
	eval "`resize -s 12 $[WIDTH+2]`"
fi

# Set times for `-t'.
if $TIME_OK && [ "$MODE" == "-t" ]; then
	TOTAL_SECONDS=$(( ($HOURS*60*60)+($MINUTES*60)+$SECONDS ))
	DEST_TOTAL_SECONDS=$(( ($DEST_HOURS*60*60)+($DEST_MINUTES*60)+$DEST_SECONDS ))

	if [ $TOTAL_SECONDS -le $DEST_TOTAL_SECONDS ]; then
		let DEST_TOTAL_SECONDS-=$TOTAL_SECONDS
	else
		DEST_TOTAL_SECONDS=$(( ((24*60*60)-$TOTAL_SECONDS)+$DEST_TOTAL_SECONDS ))
	fi

	let DEST_HOURS=($DEST_TOTAL_SECONDS/60)/60
	let DEST_MINUTES=($DEST_TOTAL_SECONDS/60)%60
	let DEST_SECONDS=($DEST_TOTAL_SECONDS%60)%60
fi

if ! $IMMEDIATE; then
	pause -r " Press any key to start timer ... "
fi
tput civis
tput smcup
bin_bg
print_info

# For verify_time to verify for a {-c}ountdown, change the mode.
MODE="-c"
TIME_OK=false
verify_time

tput cuf $TIMER_OFFSET
while $TIME_OK; do
	tput setaf $COLOR
	[ $COLOR -eq $COLOR_MAX ] && COLOR=$COLOR_MIN || let COLOR++
	manage_time
done

tput sgr0
tput cud 4
tput cr
play_sound

if ! $IMMEDIATE; then
	EXIT_PROMPT=" Press any key to exit ..."
	PROMPT_OFFSET=$(( (($SPACER_NUM-${#EXIT_PROMPT})/2)+($SPACER_NUM%2) ))
	tput cuu 4
	tput cr
	tput cuf $PROMPT_OFFSET
	echo -n $EXIT_PROMPT

	pause -r " "
fi
quit

